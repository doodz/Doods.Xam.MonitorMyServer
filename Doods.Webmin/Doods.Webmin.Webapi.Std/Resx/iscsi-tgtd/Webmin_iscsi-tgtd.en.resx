<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="check_econfigset" xml:space="preserve">
    <value>No iSCSI TGTd configuration file set!</value>
  </data>
  <data name="check_econfig" xml:space="preserve">
    <value>The iSCSI TGTd configuration file $1 was not found on your system.</value>
  </data>
  <data name="check_etgtadm" xml:space="preserve">
    <value>The iSCSI TGTd administration command $1 was not found on your system.</value>
  </data>
  <data name="check_einit" xml:space="preserve">
    <value>Bootup action $1 does not exist</value>
  </data>
  <data name="index_title" xml:space="preserve">
    <value>iSCSI TGTd</value>
  </data>
  <data name="index_stop" xml:space="preserve">
    <value>Stop iSCSI TGTd</value>
  </data>
  <data name="index_stopdesc" xml:space="preserve">
    <value>Click this button to stop the running iSCSI target. All shared devices will no longer be accessible to clients.</value>
  </data>
  <data name="index_start" xml:space="preserve">
    <value>Start iSCSI TGTd</value>
  </data>
  <data name="index_startdesc" xml:space="preserve">
    <value>Click this button to start the iSCSI target, so that shared devices are accessible to clients.</value>
  </data>
  <data name="index_restart" xml:space="preserve">
    <value>Restart iSCSI TGTd</value>
  </data>
  <data name="index_restartdesc" xml:space="preserve">
    <value>Click this button to apply the current configuration by restarting the iSCSI target.</value>
  </data>
  <data name="index_atboot" xml:space="preserve">
    <value>Start at boot?</value>
  </data>
  <data name="index_atbootdesc" xml:space="preserve">
    <value>Change this option to control whether the iSCSI target is started at boot time or not. If it is not currently started at boot and Yes is chosen, a new init script will be created.</value>
  </data>
  <data name="index_manual" xml:space="preserve">
    <value>Edit Configuration Files</value>
  </data>
  <data name="index_manualdesc" xml:space="preserve">
    <value>Manually edit any of the iSCSI target configuration files, to make changes not supported by Webmin.</value>
  </data>
  <data name="index_return" xml:space="preserve">
    <value>list of targets</value>
  </data>
  <data name="index_none" xml:space="preserve">
    <value>No iSCSI targets to export have been defined yet.</value>
  </data>
  <data name="index_add" xml:space="preserve">
    <value>Add a new iSCSI target.</value>
  </data>
  <data name="index_target" xml:space="preserve">
    <value>Target name</value>
  </data>
  <data name="index_delete" xml:space="preserve">
    <value>Delete Selected Targets</value>
  </data>
  <data name="index_lun" xml:space="preserve">
    <value>Disk devices</value>
  </data>
  <data name="index_users" xml:space="preserve">
    <value>Allowed users</value>
  </data>
  <data name="index_size" xml:space="preserve">
    <value>Total size</value>
  </data>
  <data name="index_noluns" xml:space="preserve">
    <value>None</value>
  </data>
  <data name="index_nousers" xml:space="preserve">
    <value>Any</value>
  </data>
  <data name="dtargets_err" xml:space="preserve">
    <value>Failed to delete targets</value>
  </data>
  <data name="dtargets_enone" xml:space="preserve">
    <value>None selected!</value>
  </data>
  <data name="target_title1" xml:space="preserve">
    <value>Create iSCSI Target</value>
  </data>
  <data name="target_title2" xml:space="preserve">
    <value>Edit iSCSI Target</value>
  </data>
  <data name="target_header" xml:space="preserve">
    <value>iSCSI shared device options</value>
  </data>
  <data name="target_part" xml:space="preserve">
    <value>Local disk partition</value>
  </data>
  <data name="target_raid" xml:space="preserve">
    <value>RAID device</value>
  </data>
  <data name="target_md" xml:space="preserve">
    <value>RAID device $1</value>
  </data>
  <data name="target_lvm" xml:space="preserve">
    <value>LVM logical volume</value>
  </data>
  <data name="target_lv" xml:space="preserve">
    <value>LVM VG $1, LV $2</value>
  </data>
  <data name="target_other" xml:space="preserve">
    <value>Other file or device</value>
  </data>
  <data name="target_lun" xml:space="preserve">
    <value>Device to share $1</value>
  </data>
  <data name="target_name" xml:space="preserve">
    <value>Target name</value>
  </data>
  <data name="target_egone" xml:space="preserve">
    <value>Selected target no longer exists!</value>
  </data>
  <data name="target_none" xml:space="preserve">
    <value>Nothing</value>
  </data>
  <data name="target_null" xml:space="preserve">
    <value>Temporary RAM disk of size</value>
  </data>
  <data name="target_sectors" xml:space="preserve">
    <value>sectors</value>
  </data>
  <data name="target_fileio" xml:space="preserve">
    <value>File based</value>
  </data>
  <data name="target_blockio" xml:space="preserve">
    <value>Block based (no caching, for devices only)</value>
  </data>
  <data name="target_iomode" xml:space="preserve">
    <value>IO mode</value>
  </data>
  <data name="target_wt" xml:space="preserve">
    <value>Write-through caching</value>
  </data>
  <data name="target_wb" xml:space="preserve">
    <value>Write-back caching</value>
  </data>
  <data name="target_ro" xml:space="preserve">
    <value>Read-only</value>
  </data>
  <data name="target_iuser" xml:space="preserve">
    <value>Authentication by clients</value>
  </data>
  <data name="target_iuserall" xml:space="preserve">
    <value>No authentication needed</value>
  </data>
  <data name="target_iuserbelow" xml:space="preserve">
    <value>Allow logins below ..</value>
  </data>
  <data name="target_uname" xml:space="preserve">
    <value>Username</value>
  </data>
  <data name="target_upass" xml:space="preserve">
    <value>Password</value>
  </data>
  <data name="target_ouser" xml:space="preserve">
    <value>Authentication to clients</value>
  </data>
  <data name="target_ousernone" xml:space="preserve">
    <value>Don't authenticate</value>
  </data>
  <data name="target_ousername" xml:space="preserve">
    <value>Login with username</value>
  </data>
  <data name="target_ouserpass" xml:space="preserve">
    <value>and password</value>
  </data>
  <data name="target_err" xml:space="preserve">
    <value>Failed to save target</value>
  </data>
  <data name="target_esectors" xml:space="preserve">
    <value>Missing or non-numeric number of sectors for device $1</value>
  </data>
  <data name="target_eother" xml:space="preserve">
    <value>Missing or invalid file for device $1</value>
  </data>
  <data name="target_eiuser" xml:space="preserve">
    <value>Invalid name for user $1 - no spaces are allowed</value>
  </data>
  <data name="target_eipass" xml:space="preserve">
    <value>Invalid password for user $1 - no spaces are allowed</value>
  </data>
  <data name="target_eouser" xml:space="preserve">
    <value>Missing or invalid username for authentication to clients - no spaces are allowed</value>
  </data>
  <data name="target_eopass" xml:space="preserve">
    <value>Missing or invalid password for authentication to clients - no spaces are allowed</value>
  </data>
  <data name="target_eiusernone" xml:space="preserve">
    <value>No client usernames entered</value>
  </data>
  <data name="target_iaddress" xml:space="preserve">
    <value>Allow connections from addresses</value>
  </data>
  <data name="target_iname" xml:space="preserve">
    <value>Allow connections from initiators</value>
  </data>
  <data name="target_iall" xml:space="preserve">
    <value>All</value>
  </data>
  <data name="target_ibelow" xml:space="preserve">
    <value>Entered below ..</value>
  </data>
  <data name="target_type" xml:space="preserve">
    <value>Storage type</value>
  </data>
  <data name="target_backing" xml:space="preserve">
    <value>Backing store</value>
  </data>
  <data name="target_direct" xml:space="preserve">
    <value>Direct device access</value>
  </data>
  <data name="target_cache" xml:space="preserve">
    <value>Cache writes to device?</value>
  </data>
  <data name="target_eaddr" xml:space="preserve">
    <value>Invalid allowed IP address</value>
  </data>
  <data name="target_eaname" xml:space="preserve">
    <value>Invalid allowed initiator name</value>
  </data>
  <data name="start_err" xml:space="preserve">
    <value>Failed to start iSCSI TGTd</value>
  </data>
  <data name="stop_err" xml:space="preserve">
    <value>Failed to stop iSCSI TGTd</value>
  </data>
  <data name="restart_err" xml:space="preserve">
    <value>Failed to restart iSCSI TGTd</value>
  </data>
  <data name="atboot_err" xml:space="preserve">
    <value>Failed to enable at boot</value>
  </data>
  <data name="atboot_einit" xml:space="preserve">
    <value>Init script $1 does not exist</value>
  </data>
  <data name="log_create_target" xml:space="preserve">
    <value>Created target $1</value>
  </data>
  <data name="log_delete_target" xml:space="preserve">
    <value>Deleted target $1</value>
  </data>
  <data name="log_modify_target" xml:space="preserve">
    <value>Modified target $1</value>
  </data>
  <data name="log_delete_targets" xml:space="preserve">
    <value>Deleted $1 targets</value>
  </data>
  <data name="log_start" xml:space="preserve">
    <value>Started iSCSI server</value>
  </data>
  <data name="log_stop" xml:space="preserve">
    <value>Stopped iSCSI server</value>
  </data>
  <data name="log_restart" xml:space="preserve">
    <value>Restarted iSCSI server</value>
  </data>
  <data name="log_atboot" xml:space="preserve">
    <value>Enabled iSCSI server at boot time</value>
  </data>
  <data name="log_delboot" xml:space="preserve">
    <value>Disabled iSCSI server at boot time</value>
  </data>
  <data name="log_manual" xml:space="preserve">
    <value>Manually edited configuration file</value>
  </data>
  <data name="manual_title" xml:space="preserve">
    <value>Edit Configuration File</value>
  </data>
  <data name="manual_file" xml:space="preserve">
    <value>Select file to edit:</value>
  </data>
  <data name="manual_ok" xml:space="preserve">
    <value>Open</value>
  </data>
  <data name="manual_desc" xml:space="preserve">
    <value>Use the text box below to edit the iSCSI server configuration file $1. Be careful, as no validation will be performed on your input!</value>
  </data>
  <data name="manual_err" xml:space="preserve">
    <value>Failed to save configuration file</value>
  </data>
  <data name="manual_edata" xml:space="preserve">
    <value>No contents entered!</value>
  </data>
  <data name="manual_efile" xml:space="preserve">
    <value>Invalid configuration file!</value>
  </data>
</root>
<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="cmds_run" xml:space="preserve">
    <value>Commands run in generating this page</value>
  </data>
  <data name="whats_this_title" xml:space="preserve">
    <value>What's this?</value>
  </data>
  <data name="state_enable" xml:space="preserve">
    <value>Enable</value>
  </data>
  <data name="state_disable" xml:space="preserve">
    <value>Disable</value>
  </data>
  <data name="state_refresh" xml:space="preserve">
    <value>Refresh</value>
  </data>
  <data name="state_restart" xml:space="preserve">
    <value>Restart</value>
  </data>
  <data name="state_maintenance" xml:space="preserve">
    <value>Maintenance</value>
  </data>
  <data name="state_degraded" xml:space="preserve">
    <value>Degraded</value>
  </data>
  <data name="state_clear" xml:space="preserve">
    <value>Clear</value>
  </data>
  <data name="index_title" xml:space="preserve">
    <value>Service Management Facility</value>
  </data>
  <data name="index_detail" xml:space="preserve">
    <value>SMF Service Listing</value>
  </data>
  <data name="index_svc_type" xml:space="preserve">
    <value>Select Service Type</value>
  </data>
  <data name="index_extraopts" xml:space="preserve">
    <value>Add extra options to view</value>
  </data>
  <data name="index_include_disabled" xml:space="preserve">
    <value>Include Disabled Services?</value>
  </data>
  <data name="index_apply" xml:space="preserve">
    <value>Apply to Checked Items</value>
  </data>
  <data name="index_sort_by" xml:space="preserve">
    <value>Sort by</value>
  </data>
  <data name="index_create_new_service" xml:space="preserve">
    <value>Create New Service</value>
  </data>
  <data name="index_search_instance" xml:space="preserve">
    <value>Search for Services</value>
  </data>
  <data name="index_select" xml:space="preserve">
    <value>Select</value>
  </data>
  <data name="index_delete" xml:space="preserve">
    <value>Delete</value>
  </data>
  <data name="index_Select" xml:space="preserve">
    <value>Select</value>
  </data>
  <data name="index_FMRI" xml:space="preserve">
    <value>FMRI</value>
  </data>
  <data name="index_INST" xml:space="preserve">
    <value>INST</value>
  </data>
  <data name="index_STATE" xml:space="preserve">
    <value>STATE</value>
  </data>
  <data name="index_DESC" xml:space="preserve">
    <value>DESC</value>
  </data>
  <data name="index_NSTATE" xml:space="preserve">
    <value>NSTATE</value>
  </data>
  <data name="index_SCOPE" xml:space="preserve">
    <value>SCOPE</value>
  </data>
  <data name="index_STIME" xml:space="preserve">
    <value>STIME</value>
  </data>
  <data name="index_deleteconfirm" xml:space="preserve">
    <value>Are you sure you want to permanently delete the selected service(s)?</value>
  </data>
  <data name="search_instance_title" xml:space="preserve">
    <value>Search</value>
  </data>
  <data name="search_instance_detail" xml:space="preserve">
    <value>Search/Browse for Service Instance(s)</value>
  </data>
  <data name="search_instance_go" xml:space="preserve">
    <value>Go!</value>
  </data>
  <data name="search_instance_browse" xml:space="preserve">
    <value>Browse for Service</value>
  </data>
  <data name="search_instance_noresults" xml:space="preserve">
    <value>No results for this search!</value>
  </data>
  <data name="instance_viewer_title" xml:space="preserve">
    <value>Instance Information</value>
  </data>
  <data name="instance_viewer_detail" xml:space="preserve">
    <value>Instance Details</value>
  </data>
  <data name="instance_viewer_goto_pgroup_editor" xml:space="preserve">
    <value>View/Edit Property Groups/Properties</value>
  </data>
  <data name="instance_viewer_goto_dep_viewer" xml:space="preserve">
    <value>View Dependency/Dependent Trees</value>
  </data>
  <data name="dep_viewer_title" xml:space="preserve">
    <value>Dependencies/Dependents</value>
  </data>
  <data name="dep_viewer_detail" xml:space="preserve">
    <value>Dependency/Dependent Trees for Instance</value>
  </data>
  <data name="dep_viewer_apply" xml:space="preserve">
    <value>Apply to Checked Items</value>
  </data>
  <data name="dep_viewer_depy_info" xml:space="preserve">
    <value>Dependency Tree</value>
  </data>
  <data name="dep_viewer_dept_info" xml:space="preserve">
    <value>Dependent Tree</value>
  </data>
  <data name="dep_viewer_back" xml:space="preserve">
    <value>instance viewer</value>
  </data>
  <data name="state_editor_title" xml:space="preserve">
    <value>Service State Information</value>
  </data>
  <data name="state_editor_detail" xml:space="preserve">
    <value>Instance State Details</value>
  </data>
  <data name="state_editor_stateinfo" xml:space="preserve">
    <value>Instance State Information</value>
  </data>
  <data name="state_editor_apply" xml:space="preserve">
    <value>Apply to Checked Items</value>
  </data>
  <data name="state_editor_depy_info" xml:space="preserve">
    <value>Dependency Information</value>
  </data>
  <data name="state_editor_dept_info" xml:space="preserve">
    <value>Dependent Information</value>
  </data>
  <data name="log_viewer_title" xml:space="preserve">
    <value>Logfile Viewer</value>
  </data>
  <data name="log_viewer_detail" xml:space="preserve">
    <value>View (end of) Log File</value>
  </data>
  <data name="log_viewer_show_last" xml:space="preserve">
    <value>Show last</value>
  </data>
  <data name="log_viewer_num_lines" xml:space="preserve">
    <value>lines in</value>
  </data>
  <data name="log_viewer_submit" xml:space="preserve">
    <value>Update View</value>
  </data>
  <data name="property_group_editor_title" xml:space="preserve">
    <value>Property Group Information</value>
  </data>
  <data name="property_group_editor_detail" xml:space="preserve">
    <value>Property Groups for Service</value>
  </data>
  <data name="property_group_editor_addsinst" xml:space="preserve">
    <value>Select Service/Instance</value>
  </data>
  <data name="property_group_editor_addname" xml:space="preserve">
    <value>New Property Group Name</value>
  </data>
  <data name="property_group_editor_addtype" xml:space="preserve">
    <value>New Property Group Type</value>
  </data>
  <data name="property_group_editor_addpg" xml:space="preserve">
    <value>Add New Property Group</value>
  </data>
  <data name="property_group_editor_add" xml:space="preserve">
    <value>Add</value>
  </data>
  <data name="property_group_editor_apply" xml:space="preserve">
    <value>Apply to Checked Items</value>
  </data>
  <data name="property_group_editor_deleteconfirm" xml:space="preserve">
    <value>Are you sure you want to permanently delete the selected property group(s)?</value>
  </data>
  <data name="property_group_editor_delete" xml:space="preserve">
    <value>Delete</value>
  </data>
  <data name="property_group_editor_select" xml:space="preserve">
    <value>Select</value>
  </data>
  <data name="property_group_editor_sinst" xml:space="preserve">
    <value>Service/Instance</value>
  </data>
  <data name="property_group_editor_pgroup_name" xml:space="preserve">
    <value>Property Group Name</value>
  </data>
  <data name="property_group_editor_pgroup_type" xml:space="preserve">
    <value>Property Group Type</value>
  </data>
  <data name="property_group_editor_back" xml:space="preserve">
    <value>instance viewer</value>
  </data>
  <data name="property_editor_title" xml:space="preserve">
    <value>Property Information</value>
  </data>
  <data name="property_editor_detail" xml:space="preserve">
    <value>Properties for Service/Property Group</value>
  </data>
  <data name="property_editor_addprop" xml:space="preserve">
    <value>Add New Property</value>
  </data>
  <data name="property_editor_addname" xml:space="preserve">
    <value>New Property Name</value>
  </data>
  <data name="property_editor_addtype" xml:space="preserve">
    <value>New Property Type</value>
  </data>
  <data name="property_editor_addvalue" xml:space="preserve">
    <value>New Property Value</value>
  </data>
  <data name="property_editor_add" xml:space="preserve">
    <value>Add</value>
  </data>
  <data name="property_editor_apply" xml:space="preserve">
    <value>Apply to Checked Items</value>
  </data>
  <data name="property_editor_deleteconfirm" xml:space="preserve">
    <value>Are you sure you want to permanently delete the selected property/properties?</value>
  </data>
  <data name="property_editor_delete" xml:space="preserve">
    <value>Delete</value>
  </data>
  <data name="property_editor_select" xml:space="preserve">
    <value>Select</value>
  </data>
  <data name="property_editor_prop_name" xml:space="preserve">
    <value>Property Name</value>
  </data>
  <data name="property_editor_prop_type" xml:space="preserve">
    <value>Property Type</value>
  </data>
  <data name="property_editor_prop_value" xml:space="preserve">
    <value>Property Value</value>
  </data>
  <data name="property_editor_update" xml:space="preserve">
    <value>Update</value>
  </data>
  <data name="property_editor_back" xml:space="preserve">
    <value>property groups</value>
  </data>
  <data name="whats_this" xml:space="preserve">
    <value>(What's this?)</value>
  </data>
  <data name="close_window" xml:space="preserve">
    <value>Close Window</value>
  </data>
  <data name="svc_chooser_titlesvc" xml:space="preserve">
    <value>Choose Service FMRI</value>
  </data>
  <data name="svc_chooser_titleinst" xml:space="preserve">
    <value>Choose Service Instance FMRI</value>
  </data>
  <data name="svc_chooser_titleboth" xml:space="preserve">
    <value>Choose Service/Instance FMRI</value>
  </data>
  <data name="svc_chooser_ok" xml:space="preserve">
    <value>OK</value>
  </data>
  <data name="svc_chooser_cancel" xml:space="preserve">
    <value>Cancel</value>
  </data>
  <data name="svc_chooser_fmri" xml:space="preserve">
    <value>Service FMRI Tree Location $1</value>
  </data>
  <data name="path_chooser_title" xml:space="preserve">
    <value>Choose Path FMRI</value>
  </data>
  <data name="path_chooser_ok" xml:space="preserve">
    <value>OK</value>
  </data>
  <data name="path_chooser_cancel" xml:space="preserve">
    <value>Cancel</value>
  </data>
  <data name="path_chooser_path" xml:space="preserve">
    <value>Path FMRI Tree Location $1</value>
  </data>
  <data name="editserv_title" xml:space="preserve">
    <value>Edit SMF Service</value>
  </data>
  <data name="editserv_newtitle" xml:space="preserve">
    <value>Create new SMF Service</value>
  </data>
  <data name="editserv_propviewer" xml:space="preserve">
    <value>Create/View/Modify Service</value>
  </data>
  <data name="editserv_service_detail" xml:space="preserve">
    <value>Service Details</value>
  </data>
  <data name="editserv_bundle_name" xml:space="preserve">
    <value>Service Bundle Name</value>
  </data>
  <data name="editserv_service_name" xml:space="preserve">
    <value>Service Name</value>
  </data>
  <data name="editserv_service_type" xml:space="preserve">
    <value>Type</value>
  </data>
  <data name="editserv_service_version" xml:space="preserve">
    <value>Version</value>
  </data>
  <data name="editserv_stability" xml:space="preserve">
    <value>Stability</value>
  </data>
  <data name="editserv_fmri" xml:space="preserve">
    <value>Specify FMRI</value>
  </data>
  <data name="editserv_instance_detail" xml:space="preserve">
    <value>Instance Details</value>
  </data>
  <data name="editserv_instance_name" xml:space="preserve">
    <value>Instance Name</value>
  </data>
  <data name="editserv_instance_enabled" xml:space="preserve">
    <value>Enabled?</value>
  </data>
  <data name="editserv_serv_instname" xml:space="preserve">
    <value>Select Service or Instance Level</value>
  </data>
  <data name="editserv_restarter_detail" xml:space="preserve">
    <value>Restarter Details</value>
  </data>
  <data name="editserv_depy_detail" xml:space="preserve">
    <value>Dependency Details</value>
  </data>
  <data name="editserv_depy_name" xml:space="preserve">
    <value>Dependency Name</value>
  </data>
  <data name="editserv_depy_type" xml:space="preserve">
    <value>Dependency Type</value>
  </data>
  <data name="editserv_depy_grouping" xml:space="preserve">
    <value>Dependency Grouping</value>
  </data>
  <data name="editserv_depy_restart_on" xml:space="preserve">
    <value>Restart-on Value</value>
  </data>
  <data name="editserv_dept_detail" xml:space="preserve">
    <value>Dependent Details</value>
  </data>
  <data name="editserv_dept_name" xml:space="preserve">
    <value>Dependent Name</value>
  </data>
  <data name="editserv_dept_grouping" xml:space="preserve">
    <value>Dependent Grouping</value>
  </data>
  <data name="editserv_dept_restart_on" xml:space="preserve">
    <value>Restart-on Value</value>
  </data>
  <data name="editserv_exec_detail" xml:space="preserve">
    <value>Execute Method Details</value>
  </data>
  <data name="editserv_exec_name" xml:space="preserve">
    <value>Execute Method Name</value>
  </data>
  <data name="editserv_exec_timeout_seconds" xml:space="preserve">
    <value>Timeout (seconds)</value>
  </data>
  <data name="editserv_exec_exec" xml:space="preserve">
    <value>Execute Method Path</value>
  </data>
  <data name="editserv_exec_user" xml:space="preserve">
    <value>User Method Credential</value>
  </data>
  <data name="editserv_exec_group" xml:space="preserve">
    <value>Group Method Credential</value>
  </data>
  <data name="editserv_exec_privileges" xml:space="preserve">
    <value>Privileges</value>
  </data>
  <data name="editserv_pgroup_detail" xml:space="preserve">
    <value>Property Group Details</value>
  </data>
  <data name="editserv_pgroup_name" xml:space="preserve">
    <value>Property Group Name</value>
  </data>
  <data name="editserv_pgroup_type" xml:space="preserve">
    <value>Property Group Type</value>
  </data>
  <data name="editserv_sinst_pgroup_name" xml:space="preserve">
    <value>[Service/Instance].[Property_Group]</value>
  </data>
  <data name="editserv_prop_detail" xml:space="preserve">
    <value>Property Details</value>
  </data>
  <data name="editserv_prop_name" xml:space="preserve">
    <value>Property Name</value>
  </data>
  <data name="editserv_prop_type" xml:space="preserve">
    <value>Property Type</value>
  </data>
  <data name="editserv_prop_value" xml:space="preserve">
    <value>Property Value</value>
  </data>
  <data name="editserv_template_detail" xml:space="preserve">
    <value>Template Details</value>
  </data>
  <data name="editserv_template_common_name" xml:space="preserve">
    <value>Common Name</value>
  </data>
  <data name="editserv_template_description" xml:space="preserve">
    <value>Description</value>
  </data>
  <data name="editserv_man_detail" xml:space="preserve">
    <value>Manpage details</value>
  </data>
  <data name="editserv_man_title" xml:space="preserve">
    <value>Title</value>
  </data>
  <data name="editserv_man_section" xml:space="preserve">
    <value>Section</value>
  </data>
  <data name="editserv_man_manpath" xml:space="preserve">
    <value>Manpath</value>
  </data>
  <data name="editserv_update" xml:space="preserve">
    <value>Update</value>
  </data>
  <data name="editserv_new" xml:space="preserve">
    <value>New</value>
  </data>
  <data name="editserv_finish" xml:space="preserve">
    <value>Finish</value>
  </data>
  <data name="editserv_cancel" xml:space="preserve">
    <value>Cancel</value>
  </data>
  <data name="editserv_add" xml:space="preserve">
    <value>Add</value>
  </data>
  <data name="editserv_addnew" xml:space="preserve">
    <value>Add New</value>
  </data>
  <data name="editserv_createservice" xml:space="preserve">
    <value>Create Service</value>
  </data>
  <data name="editserv_next" xml:space="preserve">
    <value>Next</value>
  </data>
  <data name="editserv_continue" xml:space="preserve">
    <value>Continue</value>
  </data>
  <data name="editserv_skip" xml:space="preserve">
    <value>Skip</value>
  </data>
  <data name="editserv_clear" xml:space="preserve">
    <value>Clear</value>
  </data>
  <data name="editserv_restarter_fmri" xml:space="preserve">
    <value>Restarter FMRI</value>
  </data>
  <data name="editserv_dependency" xml:space="preserve">
    <value>Dependency</value>
  </data>
  <data name="editstate_detail" xml:space="preserve">
    <value>Edit Service State</value>
  </data>
  <data name="editstate_stateinfo" xml:space="preserve">
    <value>Instance State Information</value>
  </data>
  <data name="editstate_depy_detail" xml:space="preserve">
    <value>Instance Dependency Information</value>
  </data>
  <data name="editstate_dept_detail" xml:space="preserve">
    <value>Instance Dependent Information</value>
  </data>
  <data name="editstate_enable" xml:space="preserve">
    <value>Enable</value>
  </data>
  <data name="editstate_disable" xml:space="preserve">
    <value>Disable</value>
  </data>
  <data name="editstate_refresh" xml:space="preserve">
    <value>Refresh</value>
  </data>
  <data name="editstate_restart" xml:space="preserve">
    <value>Restart</value>
  </data>
  <data name="editstate_clear" xml:space="preserve">
    <value>Clear</value>
  </data>
  <data name="editstate_maintenance" xml:space="preserve">
    <value>Maintenance</value>
  </data>
  <data name="editstate_degraded" xml:space="preserve">
    <value>Degraded</value>
  </data>
  <data name="whats_this_stateinfo" xml:space="preserve">
    <value>Displayed is information pertaining to the service instance state, as garnered from the svcs command. See: svcs(1). See: smf(5).</value>
  </data>
  <data name="whats_this_extraopts" xml:space="preserve">
    <value>Check these additional options, and click Update View if you want to see them in the service listing below. The meaning of the options can be found in the svcs manpage. See: svcs(1).</value>
  </data>
  <data name="whats_this_enabledonly" xml:space="preserve">
    <value>Select whether you want enabled services only to be displayed, or if you want all services (enabled and disabled) in the listing.</value>
  </data>
  <data name="whats_this_create_new_service" xml:space="preserve">
    <value>Click here if you want to add a new service.</value>
  </data>
  <data name="whats_this_serviceviewer" xml:space="preserve">
    <value>The service viewer provides a categorical view of the services available/running on the system and their states, based on the listing provided by the svcs command. Clicking on a particular tab shows services specific to that category, e.g. Network holds all services of the form svc:/network. Multiple enable/disable/refresh/restart/maintenance/degraded/clear/delete operations can be carried out by checking the candidate service instances and clicking the relevant apply button. Individual services/instances can be edited by clicking on the fmri or instance respectively, and the state of an individual service instance can be examined by clicking on the state. See: svcs(1).</value>
  </data>
  <data name="whats_this_apply" xml:space="preserve">
    <value>You can carry out operations on multiple items in the service listing by checking the appropriate services and using these buttons. See: svcadm(1M).</value>
  </data>
  <data name="whats_this_FMRI" xml:space="preserve">
    <value>The FMRI is a Universal Resource Indicator (URI) that specifies a particular service. Under the 'All' list, the full FMRI is displayed, but under particular service categories, e.g. network, the network category is not displayed. Clicking on a particular service FMRI will bring you to the service viewer where you can edit that service's properties with immediate effect (so be careful!). See: smf(5). See: svcs(1).</value>
  </data>
  <data name="whats_this_INST" xml:space="preserve">
    <value>The instance is the instance name associated with the service FMRI adjacent. A given service may have multiple instances. Clicking on the instance will bring you to the service viewer, but will only allow you to update properties for that instance. If you want to update service-level and other instance properties, click on the service FMRI. See: smf(5). See: svcs(1).</value>
  </data>
  <data name="whats_this_STATE" xml:space="preserve">
    <value>The state of the particular instance. The meanings of the various states are described in the smf manpage. See: smf(5). See: svcs(1).</value>
  </data>
  <data name="whats_this_DESC" xml:space="preserve">
    <value>A textual description of the service. See: smf(5). See: svcs(1).</value>
  </data>
  <data name="whats_this_NSTATE" xml:space="preserve">
    <value>The next state of the service, useful when the service is transitioning. A '-' indicates it is not transitioning. See: svcs(1).</value>
  </data>
  <data name="whats_this_SCOPE" xml:space="preserve">
    <value>The scope name of the service instance. See: smf(5). See: svcs(1).</value>
  </data>
  <data name="whats_this_STIME" xml:space="preserve">
    <value>The time (if today) or date the service entered the current state. See: smf(5). See: svcs(1).</value>
  </data>
  <data name="whats_this_Select" xml:space="preserve">
    <value>Check the list of services you want to enable/disable/refresh etc here.</value>
  </data>
  <data name="whats_this_service_detail" xml:space="preserve">
    <value>Specify/edit toplevel service information here: service name, version number, bundle name for manifest and stability. See: smf(5). See: svccfg(1M). See: service_bundle(4).</value>
  </data>
  <data name="whats_this_bundle_name" xml:space="preserve">
    <value>Name of service bundle in manifest. Multiple services can be bundled in the one manifest, but the name here isnt important. For already-existing services, it will be set to export as this is what svccfg does when it exports a manifest from the SMF repository. See: svccfg(1M). See: service_bundle(4).</value>
  </data>
  <data name="whats_this_service_name" xml:space="preserve">
    <value>Name of service. Convention is to use the format [general_service_category]/[name]. Categories already provided include application (higher-level applications), milestone (collections of other services, such as name services), platform (platform-specific services), system (Solaris system services), device (device-specific services), network (network/internet services) and site (site-sepecific descriptions). You can also specify your own category of course, but most services should fit comfortably in one of the above. See: smf(5).</value>
  </data>
  <data name="whats_this_service_version" xml:space="preserve">
    <value>Specify the version number of the service.</value>
  </data>
  <data name="whats_this_instance_detail" xml:space="preserve">
    <value>Specify/edit instance information here: instance name and whether it is to be enabled by default or not. See: smf(5).</value>
  </data>
  <data name="whats_this_instance_name" xml:space="preserve">
    <value>Specify the instance name. Services with only one instance generally use default as the instance name (e.g. inetd). Services which allow multiple instances of the same binary running with different configurations will require multiple instances, e.g. the chargen inetd service, which requires a stream and datagram-based version running on different ports. See: smf(5).</value>
  </data>
  <data name="whats_this_instance_enabled" xml:space="preserve">
    <value>Specify if you want this service instance to be enabled by default or not.</value>
  </data>
  <data name="whats_this_serv_instname" xml:space="preserve">
    <value>Specify whether you want to update information at the service or instance level. If a property, dependency etc exists at both the service and instance level, the instance-level value is used for that specific instance, otherwise it inherits the service-level value. This allows instances to selectively inherit values from the service-level specification, while being able to set values that they may require uniquely.</value>
  </data>
  <data name="whats_this_stability" xml:space="preserve">
    <value>Specify the stability value, - means leave unset.</value>
  </data>
  <data name="whats_this_fmri" xml:space="preserve">
    <value>Specify the relevant service/instance FMRI.</value>
  </data>
  <data name="whats_this_restarter_detail" xml:space="preserve">
    <value>By default, services use the master restarter (system/restarter service) to control their behaviour. Delegated restarters such as inetd can also be specified. As the name suggests, this involves relying on the delegated restarter to handle start/stop of services, and in the case of inetd these methods have different names to differentiate from master restarter-based services. See: inetd(1M). See: svc.startd(1M). See: smf_restarter(5).</value>
  </data>
  <data name="whats_this_exec_detail" xml:space="preserve">
    <value>Execute methods are the heart of an smf service, it is where you specify what programs to run on start/stopping the service. Services that use a delegated restarter (like inetd) have their own start/stop methods (e.g. inetd_start, inetd_stop), but services using the master restarter will generally specify a start and stop method at a minimum. See: svc.startd(1M). See: smf_method(5). See: inetd(1M).</value>
  </data>
  <data name="whats_this_exec_name" xml:space="preserve">
    <value>Provide a unique name for this execute method here. For services using the master restarter, start and stop methods are mandatory, and run respectively when the service is enabled and dependencies met; when a dependency goes offline, the service fails, the adminstrator disables the service etc. See: smf_method(5). See: inetd(1M).</value>
  </data>
  <data name="whats_this_exec_timeout_seconds" xml:space="preserve">
    <value>Methods that exceed their timeouts will be killed. For unbounded methods, set timeout to 0.</value>
  </data>
  <data name="whats_this_exec_exec" xml:space="preserve">
    <value>Provide path to execute method plus arguments. Keywords :kill and :true are provided and can be used as exec methods. The former kills all process started by the service, the latter simply returns success to the restarter. Method tokens can also be used to pass smf-related info to the method. See: smf_method(5).</value>
  </data>
  <data name="whats_this_exec_user" xml:space="preserve">
    <value>Specify an override to the default method enviroment value for user (the default method environment is inherited from init).</value>
  </data>
  <data name="whats_this_exec_group" xml:space="preserve">
    <value>Specify an override to the default method enviroment valuefor group (the default method environment is inherited from init). </value>
  </data>
  <data name="whats_this_exec_privileges" xml:space="preserve">
    <value>Specify an override to the default method enviroment privileges.</value>
  </data>
  <data name="whats_this_depy_detail" xml:space="preserve">
    <value>Dependencies provide a way of specifying what services your service requires to be (sometimes not) running before it runs. Calling out dependencies is one of the key benefits of SMF, as it imposes a deterministic structure on what was a very tangled web of init scripts etc. Dependencies provide a lot of flexibility in that you can specify that your service will wait for a particular dependency to come online, wait for one member of a group (e.g. whichever nameservice is configured), or even only run if another service isnt running. See: smf(5).</value>
  </data>
  <data name="whats_this_depy_name" xml:space="preserve">
    <value>Provide a unique name for this dependency here.</value>
  </data>
  <data name="whats_this_depy_type" xml:space="preserve">
    <value>Select dependency type (path or service). Path dependencies require the named file to be in place (?). An example of a valid fmri for a path dependency would be file:://localhost/path2file. Service dependencies are just fmris identifying the service depended upon.</value>
  </data>
  <data name="whats_this_depy_grouping" xml:space="preserve">
    <value>Select a grouping value for your dependency. Grouping values determine the nature of the dependency relation. For example, for require_all, all dependencies in group need to be online/degraded before the service starts, while for require_any, any of the group are required to be online/degraded. For optional_all, all enabled and able-to-run services must be online, while for exclude_all, if the dependency is online/degraded, the service should not be run.</value>
  </data>
  <data name="whats_this_depy_restart_on" xml:space="preserve">
    <value>Specify the fault propogation model here, i.e. how should my service react to faults in the dependency? Values are none (we dont care about the dependency after startup), fault (restart if the dependency has a fault), restart (restart if the dependency is restarted), and refresh (restart if the dependency is refreshed).</value>
  </data>
  <data name="whats_this_dept_detail" xml:space="preserve">
    <value>Dependents might seem a little confusing - why have a mechanism to specify what services depend on my service, cant i just add a dependency in the candidate dependent? Dependents address the situation where you dont own the dependent manifest and cant do this. As a consequence, dependents look very much like dependencies, but rather than specifying that the current service depends on this dependency, we are saying that the current service is a dependency for this child service/dependent. See: smf(5).</value>
  </data>
  <data name="whats_this_dept_name" xml:space="preserve">
    <value>Provide a unique name for this dependent here.</value>
  </data>
  <data name="whats_this_dept_grouping" xml:space="preserve">
    <value>Select a grouping value which this service will adhere to for its dependent.  Grouping values determine the nature of the dependency relation. For example, for require_all, all services in the group that specify the dependent need to be online/degraded before the dependent starts, while for require_any, any of the group are required to be online/degraded. For optional_all, all enabled and able-to-run services must be online, while for exclude_all, if the service is online/degraded, the dependent service should not be run.</value>
  </data>
  <data name="whats_this_dept_restart_on" xml:space="preserve">
    <value>Specify the fault propogation model here, i.e. how should this service propogate faults to its dependent?  Values are none (dependent doesnt care about the service after startup), fault (restart dependent if the service has a fault), restart (restart dependent if the service is restarted), and refresh (restart dependent if the service is refreshed).</value>
  </data>
  <data name="whats_this_pgroup_detail" xml:space="preserve">
    <value>In smf, all service information, dependencies, exec methods etc are stored as properties within property groups. In addition, services may need to specify other properties, e.g. inetd services need to specify properties that the inetd delegated restarter understands and needs. Services can also store their own application data in properties. See: smf(5).</value>
  </data>
  <data name="whats_this_pgroup_name" xml:space="preserve">
    <value>Specify property group name. See: smf(5).</value>
  </data>
  <data name="whats_this_pgroup_type" xml:space="preserve">
    <value>Specify property group type. See: smf(5).</value>
  </data>
  <data name="whats_this_sinst_pgroup_name" xml:space="preserve">
    <value>Select property group at appropriate service/instance level. This allows creation/update of properties at both instance-specific and service level.</value>
  </data>
  <data name="whats_this_prop_detail" xml:space="preserve">
    <value>Properties are associated with property groups and used to store service-relevant information. See: smf(5).</value>
  </data>
  <data name="whats_this_prop_name" xml:space="preserve">
    <value>Specify property name. See: smf(5).</value>
  </data>
  <data name="whats_this_prop_type" xml:space="preserve">
    <value>Specify property type. Valid types are count, integer, opaque, host, hostname, net_address_v4, net_address_v6, time, astring, ustring, boolean, fmri, uri. See: smf(5).</value>
  </data>
  <data name="whats_this_prop_value" xml:space="preserve">
    <value>Specify property value. See: smf(5).</value>
  </data>
  <data name="whats_this_man_detail" xml:space="preserve">
    <value>Provide information regarding manpage documentation for service. See: man(1).</value>
  </data>
  <data name="whats_this_man_title" xml:space="preserve">
    <value>Specify manpage title. See: man(1).</value>
  </data>
  <data name="whats_this_man_section" xml:space="preserve">
    <value>Specify manpage section. See: man(1).</value>
  </data>
  <data name="whats_this_man_manpath" xml:space="preserve">
    <value>Specify manpath. See: man(1).</value>
  </data>
  <data name="whats_this_template_detail" xml:space="preserve">
    <value>Provide details of service, its commonly used name and a description of what the service does.</value>
  </data>
  <data name="whats_this_template_common_name" xml:space="preserve">
    <value>Specify common name for service.</value>
  </data>
  <data name="whats_this_template_description" xml:space="preserve">
    <value>Describe the service.</value>
  </data>
  <data name="wizard_back" xml:space="preserve">
    <value>Back</value>
  </data>
  <data name="wizard_next" xml:space="preserve">
    <value>Next</value>
  </data>
  <data name="wizard_add" xml:space="preserve">
    <value>Add</value>
  </data>
  <data name="wizard_update" xml:space="preserve">
    <value>Update</value>
  </data>
  <data name="wizard_new" xml:space="preserve">
    <value>New</value>
  </data>
  <data name="wizard_remove" xml:space="preserve">
    <value>Remove</value>
  </data>
  <data name="wizard_finish" xml:space="preserve">
    <value>Finish</value>
  </data>
  <data name="smfwizard_title" xml:space="preserve">
    <value>Create SMF Service</value>
  </data>
  <data name="smfwizard_service_heading" xml:space="preserve">
    <value>Enter Service Information</value>
  </data>
  <data name="smfwizard_service_description" xml:space="preserve">
    <value>Specify/edit toplevel service information here. For service name, the convention is to use the format [general_service_category]/[name]. Categories already provided include application (higher-level applications), milestone (collections of other services, such as nameservices), platform (platform-specific services), system (Solaris system services), device (device-specific services), network (network/internet services) and site (site-sepecific descriptions). You can also specify your own category of course, but most services should fit comfortably in one of the above. Also specify an integer version number. See: smf(5). See: svccfg(1M). See: service_bundle(4).</value>
  </data>
  <data name="smfwizard_service_name" xml:space="preserve">
    <value>Enter Service Name</value>
  </data>
  <data name="smfwizard_service_name_error" xml:space="preserve">
    <value>*Name must be non-null!*</value>
  </data>
  <data name="smfwizard_service_version" xml:space="preserve">
    <value>Enter Service Version</value>
  </data>
  <data name="smfwizard_service_version_error" xml:space="preserve">
    <value>*Version must be a positive number!*</value>
  </data>
  <data name="smfwizard_instance_heading" xml:space="preserve">
    <value>Enter Instance Information</value>
  </data>
  <data name="smfwizard_instance_description" xml:space="preserve">
    <value>Specify the instance name. Services with only one instance generally use default as the instance name (e.g. inetd). Services which allow multiple instances of the same binary running with different configurations will require multiple instances, e.g. the chargen inetd service, which requires both a stream and datagram-based version running on the same port. See: smf(5).</value>
  </data>
  <data name="smfwizard_instance_name" xml:space="preserve">
    <value>Specify Instance Name</value>
  </data>
  <data name="smfwizard_instance_name_error" xml:space="preserve">
    <value>*Name must be non-null!*</value>
  </data>
  <data name="smfwizard_instance_enabled" xml:space="preserve">
    <value>Specify if you want this service instance to be enabled by default or not.</value>
  </data>
  <data name="smfwizard_instance_enabled_error" xml:space="preserve">
    <value>*Enabled must be true/false*</value>
  </data>
  <data name="smfwizard_sinst_name" xml:space="preserve">
    <value>Select Service/Specific Instance that Properties apply to</value>
  </data>
  <data name="smfwizard_sinst_error" xml:space="preserve">
    <value>*Service or Instance Must be Selected!*</value>
  </data>
  <data name="smfwizard_restarter_heading" xml:space="preserve">
    <value>Enter Restarter Information</value>
  </data>
  <data name="smfwizard_restarter_description" xml:space="preserve">
    <value>By default, services use the master restarter (system/restarter service) to control their behaviour. Delegated restarters such as inetd can also be specified. As the name suggests, this involves relying on the delegated restarter to handle start/stop of services, and in the case of inetd these methods have different names to differentiate from master restarter-based services. See: inetd(1M). See: svc.startd(1M). See: smf_restarter(5).</value>
  </data>
  <data name="smfwizard_restarter_fmri" xml:space="preserve">
    <value>Enter FMRI identifying restarter</value>
  </data>
  <data name="smfwizard_restarter_fmri_error" xml:space="preserve">
    <value>*Not a valid FMRI!*</value>
  </data>
  <data name="smfwizard_dependency_heading" xml:space="preserve">
    <value>Enter Dependency Information</value>
  </data>
  <data name="smfwizard_dependency_description" xml:space="preserve">
    <value>Dependencies provide a way of specifying what services your service requires to be (sometimes not) running before it runs. Calling out dependencies is one of the key benefits of SMF, as it imposes a deterministic structure on what was a very tangled web of init scripts etc. Dependencies provide a lot of flexibility in that you can specify groupings that signify your service will wait for all dependencies to come online (require_all), wait for any member of a group (require_any), wait for all enabled members (optional_all), or even only run if group isnt enabled (exclude_all). Also specify the fault propogation model here, i.e. how should my service react to faults in the dependency? Values are none (we dont care about the dependency after startup), fault (restart if the dependency has a fault), restart (restart if the dependency is restarted), and refresh (restart if the dependency is refreshed). Finally specify the fmri identifying the dependency and the stability (optional). See: smf(5).</value>
  </data>
  <data name="smfwizard_dependency_name" xml:space="preserve">
    <value>Enter Dependency Name</value>
  </data>
  <data name="smfwizard_dependency_name_error" xml:space="preserve">
    <value>*Name must be non-null!*</value>
  </data>
  <data name="smfwizard_dependency_type" xml:space="preserve">
    <value>Enter Dependency Type</value>
  </data>
  <data name="smfwizard_dependency_type_error" xml:space="preserve">
    <value>*Type must be non-null!*</value>
  </data>
  <data name="smfwizard_dependency_grouping" xml:space="preserve">
    <value>Select Dependency Grouping</value>
  </data>
  <data name="smfwizard_dependency_grouping_error" xml:space="preserve">
    <value>*Grouping must be non-null!*</value>
  </data>
  <data name="smfwizard_dependency_restart_on" xml:space="preserve">
    <value>Select restart-on value</value>
  </data>
  <data name="smfwizard_dependency_restart_on_error" xml:space="preserve">
    <value>*Restart-on value must be non-null!*</value>
  </data>
  <data name="smfwizard_dependency_fmri" xml:space="preserve">
    <value>Enter FMRI identifying dependency</value>
  </data>
  <data name="smfwizard_dependency_fmri_error" xml:space="preserve">
    <value>*Not a valid FMRI!*</value>
  </data>
  <data name="smfwizard_dependency_stability" xml:space="preserve">
    <value>Select dependency stability value</value>
  </data>
  <data name="smfwizard_dependency_stability_error" xml:space="preserve">
    <value>*Stability must be non-null!*</value>
  </data>
  <data name="smfwizard_dependent_heading" xml:space="preserve">
    <value>Enter Dependent Information</value>
  </data>
  <data name="smfwizard_dependent_description" xml:space="preserve">
    <value>Dependents might seem a little confusing - why have a mechanism to specify what services depend on my service, cant i just add a dependency in the candidate dependent? Dependents address the situation where you dont own the dependent manifest and cant do this. As a consequence, dependents look very much like dependencies, but rather than specifying that the current service depends on this dependency, we are saying that the current service is a dependency for this child service/dependent. Like dependencies, we can specify groupings, restart_on values. For dependents, the FMRI refers to the dependent (child) service of course. See: smf(5).</value>
  </data>
  <data name="smfwizard_dependent_name" xml:space="preserve">
    <value>Enter Dependent Name</value>
  </data>
  <data name="smfwizard_dependent_name_error" xml:space="preserve">
    <value>*Name must be non-null!*</value>
  </data>
  <data name="smfwizard_dependent_type" xml:space="preserve">
    <value>Enter Dependent Type</value>
  </data>
  <data name="smfwizard_dependent_type_error" xml:space="preserve">
    <value>*Type must be non-null!*</value>
  </data>
  <data name="smfwizard_dependent_grouping" xml:space="preserve">
    <value>Select Dependent Grouping</value>
  </data>
  <data name="smfwizard_dependent_grouping_error" xml:space="preserve">
    <value>*Grouping must be non-null!*</value>
  </data>
  <data name="smfwizard_dependent_restart_on" xml:space="preserve">
    <value>Select restart-on value</value>
  </data>
  <data name="smfwizard_dependent_restart_on_error" xml:space="preserve">
    <value>*Restart-on value must be non-null!*</value>
  </data>
  <data name="smfwizard_dependent_fmri" xml:space="preserve">
    <value>Enter FMRI identifying dependent</value>
  </data>
  <data name="smfwizard_dependent_fmri_error" xml:space="preserve">
    <value>*Not a valid FMRI!*</value>
  </data>
  <data name="smfwizard_dependent_stability" xml:space="preserve">
    <value>Select dependent stability value</value>
  </data>
  <data name="smfwizard_dependent_stability_error" xml:space="preserve">
    <value>*Stability must be non-null!*</value>
  </data>
  <data name="smfwizard_exec_heading" xml:space="preserve">
    <value>Enter Execute Method Information</value>
  </data>
  <data name="smfwizard_exec_description" xml:space="preserve">
    <value>Execute methods are the heart of an smf service, it is where you specify what programs to run on start/stopping the service. Services that use a delegated restarter (like inetd) have their own names for start/stop methods (inetd_start, inetd_stop), but services using the master restarter will generally specify exec_methods named start and stop method at a minimum. Methods that exceed the timeout value (specified in seconds) will be killed. For unbounded methods, set timeout to 0. For the exec method itself, you must provide a path to the method plus arguments. Keywords :kill and :true are provided and can be used as exec methods. The former kills all processes started by the service, the latter simply returns success to the restarter. Method tokens can also be used to pass smf-related info to the method. Overrides for user/group/privileges can be specified to the default method environment (inherited from init). See: smf_method(5). See: svc.startd(1M). See: inetd(1M).</value>
  </data>
  <data name="smfwizard_exec_name" xml:space="preserve">
    <value>Enter Execute Method Name</value>
  </data>
  <data name="smfwizard_exec_name_error" xml:space="preserve">
    <value>*Name must be non-null!*</value>
  </data>
  <data name="smfwizard_exec_timeout" xml:space="preserve">
    <value>Enter timeout (seconds) after which execute method is killed</value>
  </data>
  <data name="smfwizard_exec_timeout_error" xml:space="preserve">
    <value>*Timeout must be an integer!*</value>
  </data>
  <data name="smfwizard_exec_exec" xml:space="preserve">
    <value>Enter path to execute method plus arguments</value>
  </data>
  <data name="smfwizard_exec_exec_error" xml:space="preserve">
    <value>*Execute method must be non-null!*</value>
  </data>
  <data name="smfwizard_exec_user" xml:space="preserve">
    <value>Specify an override to the default method enviroment user</value>
  </data>
  <data name="smfwizard_exec_user_error" xml:space="preserve">
    <value>*Invalid user!*</value>
  </data>
  <data name="smfwizard_exec_group" xml:space="preserve">
    <value>Specify an override to the default method enviroment group</value>
  </data>
  <data name="smfwizard_exec_group_error" xml:space="preserve">
    <value>*Invalid group!*</value>
  </data>
  <data name="smfwizard_exec_privileges" xml:space="preserve">
    <value>Specify an override to the default method enviroment privileges</value>
  </data>
  <data name="smfwizard_exec_privileges_error" xml:space="preserve">
    <value>*Invalid privileges!*</value>
  </data>
  <data name="smfwizard_property_group_heading" xml:space="preserve">
    <value>Enter Property Group Details</value>
  </data>
  <data name="smfwizard_property_group_description" xml:space="preserve">
    <value>In smf, all service information, dependencies, exec methods etc are stored as properties within property groups. In addition, services may need to specify other properties, e.g. inetd services need to specify properties that the inetd delegated restarter understands and needs. Services can also store their own application data in properties. See: smf(5).</value>
  </data>
  <data name="smfwizard_property_group_name" xml:space="preserve">
    <value>Specify property group name</value>
  </data>
  <data name="smfwizard_property_group_name_error" xml:space="preserve">
    <value>*Name must be non-null!*</value>
  </data>
  <data name="smfwizard_property_group_type" xml:space="preserve">
    <value>Specify property group type</value>
  </data>
  <data name="smfwizard_property_group_type_error" xml:space="preserve">
    <value>*Type must be non-null!*</value>
  </data>
  <data name="smfwizard_property_group_stability" xml:space="preserve">
    <value>Select property_group stability value</value>
  </data>
  <data name="smfwizard_property_group_stability_error" xml:space="preserve">
    <value>*Stability must be non-null!*</value>
  </data>
  <data name="smfwizard_property_heading" xml:space="preserve">
    <value>Enter Property Details</value>
  </data>
  <data name="smfwizard_property_description" xml:space="preserve">
    <value>Properties are associated with property groups and used to store service- or instance-relevant information. See: smf(5).</value>
  </data>
  <data name="smfwizard_pgroup_name" xml:space="preserve">
    <value>Select Property Group</value>
  </data>
  <data name="mfwizard_pgroup_name_error" xml:space="preserve">
    <value>*Property Group must be non-null!*</value>
  </data>
  <data name="smfwizard_property_name" xml:space="preserve">
    <value>Enter Property Name</value>
  </data>
  <data name="smfwizard_property_name_error" xml:space="preserve">
    <value>*Name must be non-null!*</value>
  </data>
  <data name="smfwizard_property_type" xml:space="preserve">
    <value>Select Property Type</value>
  </data>
  <data name="smfwizard_property_type_error" xml:space="preserve">
    <value>*Type must be non-null!*</value>
  </data>
  <data name="smfwizard_property_value" xml:space="preserve">
    <value>Enter Property Value</value>
  </data>
  <data name="smfwizard_property_value_error" xml:space="preserve">
    <value>*Invalid value!*</value>
  </data>
  <data name="smfwizard_template_heading" xml:space="preserve">
    <value>Enter Template Details</value>
  </data>
  <data name="smfwizard_template_description" xml:space="preserve">
    <value>Provide details of service, its commonly used name and a description of what the service does.</value>
  </data>
  <data name="smfwizard_template_common_name" xml:space="preserve">
    <value>Specify common name for service</value>
  </data>
  <data name="smfwizard_template_common_name_error" xml:space="preserve">
    <value>*Common name must be non-null!*</value>
  </data>
  <data name="smfwizard_template_svc_description" xml:space="preserve">
    <value>Describe the service</value>
  </data>
  <data name="smfwizard_template_svc_description_error" xml:space="preserve">
    <value>*Description must be non-null!*</value>
  </data>
  <data name="smfwizard_manpage_heading" xml:space="preserve">
    <value>Enter ManPage Details</value>
  </data>
  <data name="smfwizard_manpage_description" xml:space="preserve">
    <value>Provide information regarding manpage documentation for service. See: man(1).</value>
  </data>
  <data name="smfwizard_manpage_title" xml:space="preserve">
    <value>Specify manpage title</value>
  </data>
  <data name="smfwizard_manpage_title_error" xml:space="preserve">
    <value>*Title must be non-null!*</value>
  </data>
  <data name="smfwizard_manpage_section" xml:space="preserve">
    <value>Specify manpage section</value>
  </data>
  <data name="smfwizard_manpage_section_error" xml:space="preserve">
    <value>*Section must be non-null!*</value>
  </data>
  <data name="smfwizard_manpage_manpath" xml:space="preserve">
    <value>Specify manpath</value>
  </data>
  <data name="smfwizard_manpage_manpath_error" xml:space="preserve">
    <value>*Manpath must be non-null!*</value>
  </data>
  <data name="__norefs" xml:space="preserve">
    <value>1</value>
  </data>
</root>
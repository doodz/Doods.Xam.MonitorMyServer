<?xml version="1.0" encoding="utf-8"?>
<root>
  <!-- 
    Microsoft ResX Schema 
    
    Version 2.0
    
    The primary goals of this format is to allow a simple XML format 
    that is mostly human readable. The generation and parsing of the 
    various data types are done through the TypeConverter classes 
    associated with the data types.
    
    Example:
    
    ... ado.net/XML headers & schema ...
    <resheader name="resmimetype">text/microsoft-resx</resheader>
    <resheader name="version">2.0</resheader>
    <resheader name="reader">System.Resources.ResXResourceReader, System.Windows.Forms, ...</resheader>
    <resheader name="writer">System.Resources.ResXResourceWriter, System.Windows.Forms, ...</resheader>
    <data name="Name1"><value>this is my long string</value><comment>this is a comment</comment></data>
    <data name="Color1" type="System.Drawing.Color, System.Drawing">Blue</data>
    <data name="Bitmap1" mimetype="application/x-microsoft.net.object.binary.base64">
        <value>[base64 mime encoded serialized .NET Framework object]</value>
    </data>
    <data name="Icon1" type="System.Drawing.Icon, System.Drawing" mimetype="application/x-microsoft.net.object.bytearray.base64">
        <value>[base64 mime encoded string representing a byte array form of the .NET Framework object]</value>
        <comment>This is a comment</comment>
    </data>
                
    There are any number of "resheader" rows that contain simple 
    name/value pairs.
    
    Each data row contains a name, and value. The row also contains a 
    type or mimetype. Type corresponds to a .NET class that support 
    text/value conversion through the TypeConverter architecture. 
    Classes that don't support this are serialized and stored with the 
    mimetype set.
    
    The mimetype is used for serialized objects, and tells the 
    ResXResourceReader how to depersist the object. This is currently not 
    extensible. For a given mimetype the value must be set accordingly:
    
    Note - application/x-microsoft.net.object.binary.base64 is the format 
    that the ResXResourceWriter will generate, however the reader can 
    read any of the formats listed below.
    
    mimetype: application/x-microsoft.net.object.binary.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Binary.BinaryFormatter
            : and then encoded with base64 encoding.
    
    mimetype: application/x-microsoft.net.object.soap.base64
    value   : The object must be serialized with 
            : System.Runtime.Serialization.Formatters.Soap.SoapFormatter
            : and then encoded with base64 encoding.

    mimetype: application/x-microsoft.net.object.bytearray.base64
    value   : The object must be serialized into a byte array 
            : using a System.ComponentModel.TypeConverter
            : and then encoded with base64 encoding.
    -->
  <xsd:schema id="root" xmlns="" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:msdata="urn:schemas-microsoft-com:xml-msdata">
    <xsd:import namespace="http://www.w3.org/XML/1998/namespace" />
    <xsd:element name="root" msdata:IsDataSet="true">
      <xsd:complexType>
        <xsd:choice maxOccurs="unbounded">
          <xsd:element name="metadata">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" />
              </xsd:sequence>
              <xsd:attribute name="name" use="required" type="xsd:string" />
              <xsd:attribute name="type" type="xsd:string" />
              <xsd:attribute name="mimetype" type="xsd:string" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="assembly">
            <xsd:complexType>
              <xsd:attribute name="alias" type="xsd:string" />
              <xsd:attribute name="name" type="xsd:string" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="data">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
                <xsd:element name="comment" type="xsd:string" minOccurs="0" msdata:Ordinal="2" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" msdata:Ordinal="1" />
              <xsd:attribute name="type" type="xsd:string" msdata:Ordinal="3" />
              <xsd:attribute name="mimetype" type="xsd:string" msdata:Ordinal="4" />
              <xsd:attribute ref="xml:space" />
            </xsd:complexType>
          </xsd:element>
          <xsd:element name="resheader">
            <xsd:complexType>
              <xsd:sequence>
                <xsd:element name="value" type="xsd:string" minOccurs="0" msdata:Ordinal="1" />
              </xsd:sequence>
              <xsd:attribute name="name" type="xsd:string" use="required" />
            </xsd:complexType>
          </xsd:element>
        </xsd:choice>
      </xsd:complexType>
    </xsd:element>
  </xsd:schema>
  <resheader name="resmimetype">
    <value>text/microsoft-resx</value>
  </resheader>
  <resheader name="version">
    <value>2.0</value>
  </resheader>
  <resheader name="reader">
    <value>System.Resources.ResXResourceReader, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <resheader name="writer">
    <value>System.Resources.ResXResourceWriter, System.Windows.Forms, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089</value>
  </resheader>
  <data name="index_title" xml:space="preserve">
    <value>SSL 터널</value>
  </data>
  <data name="index_name" xml:space="preserve">
    <value>서비스 이름</value>
  </data>
  <data name="index_port" xml:space="preserve">
    <value>TCP 포트</value>
  </data>
  <data name="index_active" xml:space="preserve">
    <value>유효한?</value>
  </data>
  <data name="index_command" xml:space="preserve">
    <value>STunnel 명령</value>
  </data>
  <data name="index_add" xml:space="preserve">
    <value>새로운 SSL 터널을 추가하십시오.</value>
  </data>
  <data name="index_none" xml:space="preserve">
    <value>현재 &lt;tt&gt;inetd&lt;/tt&gt; 또는 &lt;tt&gt;xinetd&lt;/tt&gt;에서 실행하도록 SSL 터널이 설정되어 있지 않습니다.</value>
  </data>
  <data name="index_einetd" xml:space="preserve">
    <value>&lt;tt&gt;inetd&lt;/tt&gt; 또는 &lt;tt&gt;xinetd&lt;/tt&gt;가 시스템에 설치되어 있지 않습니다. &lt;tt&gt;터널&lt;/tt&gt;로 전달하기 위해 네트워크 연결 수락을 수신해야합니다.</value>
  </data>
  <data name="index_apply" xml:space="preserve">
    <value>변경 승인</value>
  </data>
  <data name="index_applymsg1" xml:space="preserve">
    <value>실행중인 &lt;tt&gt;inetd&lt;/tt&gt; 및 &lt;tt&gt;xinetd&lt;/tt&gt; 프로세스로 HUP 신호를 보내 현재 SSL 터널 구성을 활성화하려면이 버튼을 클릭하십시오.</value>
  </data>
  <data name="index_applymsg2" xml:space="preserve">
    <value>실행중인 &lt;tt&gt;inetd&lt;/tt&gt; 프로세스로 HUP 신호를 보내 현재 SSL 터널 구성을 활성화하려면이 버튼을 클릭하십시오.</value>
  </data>
  <data name="index_applymsg3" xml:space="preserve">
    <value>실행중인 &lt;tt&gt;xinetd&lt;/tt&gt; 프로세스로 HUP 신호를 보내 현재 SSL 터널 구성을 활성화하려면이 버튼을 클릭하십시오.</value>
  </data>
  <data name="index_return" xml:space="preserve">
    <value>SSL 터널 목록</value>
  </data>
  <data name="index_action" xml:space="preserve">
    <value>터널 목적지</value>
  </data>
  <data name="index_cmd" xml:space="preserve">
    <value>실행 명령 $1 </value>
  </data>
  <data name="index_remote" xml:space="preserve">
    <value>호스트 $1 에 연결</value>
  </data>
  <data name="index_rport" xml:space="preserve">
    <value>포트 $1 에 연결</value>
  </data>
  <data name="index_version" xml:space="preserve">
    <value>터널 버전 $1 </value>
  </data>
  <data name="index_eversion" xml:space="preserve">
    <value>시스템에 설치된 STunnel의 버전은 $1 이지만이 모듈은 $2 이상의 버전을 지원하지 않습니다.</value>
  </data>
  <data name="index_conf" xml:space="preserve">
    <value>구성 파일 $1 에서</value>
  </data>
  <data name="index_noconf" xml:space="preserve">
    <value>구성 파일이 없습니다!</value>
  </data>
  <data name="index_delete" xml:space="preserve">
    <value>선택된 터널 삭제</value>
  </data>
  <data name="edit_title" xml:space="preserve">
    <value>SSL 터널 편집</value>
  </data>
  <data name="create_title" xml:space="preserve">
    <value>SSL 터널 생성</value>
  </data>
  <data name="edit_header1" xml:space="preserve">
    <value>터널 소스 옵션</value>
  </data>
  <data name="edit_name" xml:space="preserve">
    <value>서비스 이름</value>
  </data>
  <data name="edit_port" xml:space="preserve">
    <value>TCP 포트</value>
  </data>
  <data name="edit_active" xml:space="preserve">
    <value>유효한?</value>
  </data>
  <data name="edit_header2" xml:space="preserve">
    <value>터널 대상 옵션</value>
  </data>
  <data name="edit_mode0" xml:space="preserve">
    <value>&lt;tt&gt;inetd&lt;/tt&gt; 스타일 프로그램을 실행하십시오.</value>
  </data>
  <data name="edit_mode1" xml:space="preserve">
    <value>PTY에서 프로그램 실행</value>
  </data>
  <data name="edit_mode2" xml:space="preserve">
    <value>원격 호스트에 연결</value>
  </data>
  <data name="edit_cmd" xml:space="preserve">
    <value>프로그램 경로</value>
  </data>
  <data name="edit_args" xml:space="preserve">
    <value>논쟁과 함께</value>
  </data>
  <data name="edit_rhost" xml:space="preserve">
    <value>원격 호스트 이름</value>
  </data>
  <data name="edit_rport" xml:space="preserve">
    <value>원격 포트</value>
  </data>
  <data name="edit_header3" xml:space="preserve">
    <value>다른 옵션</value>
  </data>
  <data name="edit_pem" xml:space="preserve">
    <value>SSL 인증서 및 키 파일</value>
  </data>
  <data name="edit_pem0" xml:space="preserve">
    <value>컴파일 된 기본값</value>
  </data>
  <data name="edit_pem1" xml:space="preserve">
    <value>Webmin의 인증서 사용</value>
  </data>
  <data name="edit_pem2" xml:space="preserve">
    <value>파일에서 인증서 사용</value>
  </data>
  <data name="edit_cmode" xml:space="preserve">
    <value>터널 모드</value>
  </data>
  <data name="edit_cmode0" xml:space="preserve">
    <value>SSL을 수락하고 정상적으로 연결</value>
  </data>
  <data name="edit_cmode1" xml:space="preserve">
    <value>정상 수락 및 SSL 연결</value>
  </data>
  <data name="edit_tcpw" xml:space="preserve">
    <value>TCP 래퍼 이름</value>
  </data>
  <data name="edit_auto" xml:space="preserve">
    <value>자동적 인</value>
  </data>
  <data name="edit_iface" xml:space="preserve">
    <value>발신 소스 주소</value>
  </data>
  <data name="edit_type" xml:space="preserve">
    <value>로부터 달아 나다</value>
  </data>
  <data name="save_err" xml:space="preserve">
    <value>SSL 터널을 저장하지 못했습니다</value>
  </data>
  <data name="save_enclash" xml:space="preserve">
    <value>서비스 이름 $2 이 (가) 포트 $1 에서 이미 사용 중입니다.</value>
  </data>
  <data name="save_einetd" xml:space="preserve">
    <value>$1 이라는 inetd 서비스가 이미 있습니다.</value>
  </data>
  <data name="save_ename" xml:space="preserve">
    <value>없거나 잘못된 서비스 이름</value>
  </data>
  <data name="save_eport" xml:space="preserve">
    <value>포트 번호가 없거나 유효하지 않습니다</value>
  </data>
  <data name="save_ecmd" xml:space="preserve">
    <value>실행할 프로그램이 없거나 유효하지 않습니다</value>
  </data>
  <data name="save_erhost" xml:space="preserve">
    <value>잘못된 원격 호스트 이름</value>
  </data>
  <data name="save_erport" xml:space="preserve">
    <value>잘못된 원격 포트</value>
  </data>
  <data name="save_epclash" xml:space="preserve">
    <value>포트 $1 은 (는) 서비스 $2 에서 이미 사용 중입니다.</value>
  </data>
  <data name="save_epem" xml:space="preserve">
    <value>SSL 인증서 파일 $1 이 (가) 없습니다</value>
  </data>
  <data name="save_etcpw" xml:space="preserve">
    <value>누락되거나 잘못된 TCP 래퍼 이름</value>
  </data>
  <data name="save_eiface" xml:space="preserve">
    <value>발신 소스 주소가 없거나 잘못되었습니다</value>
  </data>
  <data name="save_exinetd" xml:space="preserve">
    <value>$1 이라는 xinetd 서비스가 이미 있습니다</value>
  </data>
  <data name="save_export" xml:space="preserve">
    <value>포트 $1 은 (는) xinetd 서비스 $2 에서 이미 사용 중입니다</value>
  </data>
  <data name="log_apply" xml:space="preserve">
    <value>적용 변경</value>
  </data>
  <data name="log_create" xml:space="preserve">
    <value>SSL 터널 $1 생성</value>
  </data>
  <data name="log_delete" xml:space="preserve">
    <value>SSL 터널 $1 을 (를) 삭제했습니다.</value>
  </data>
  <data name="log_modify" xml:space="preserve">
    <value>수정 된 SSL 터널 $1 </value>
  </data>
  <data name="log_delete_stunnels" xml:space="preserve">
    <value>$1 SSL 터널을 삭제했습니다.</value>
  </data>
</root>